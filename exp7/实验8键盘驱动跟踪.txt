键盘驱动从键盘中断开始
init/main.c
void main(void)
{
	tty_init();
}

kernel/chr_drv/tty_io.c
void tty_init(void)
{
	con_init();
}

kernel/chr_drv/console.c
//因为键盘也是console的一部分
void con_init(void) 
{ 
	set_trap_gate(0x21, &keyboard_interrupt); 
}

kernel/chr_drv/keyboard.S
.globl _keyboard_interrupt
_keyboard_interrupt:
	inb $0x60,%al 														//从端口0x60读扫描码->al
	call key_table(,%eax,4)										//调用key_table+eax*4
	... 
	push $0 
	call _do_tty_interrupt				
	
	
	其中，key_table是一个函数数组
	kernel/chr_drv/keyboard.S
	key_table:
		.long none,do_self,do_self,do_self 			//扫描码00-03
		
		其中do_self，显示字符通常都用此函数处理
		do_self:
			lea alt_map,%ebx											//找到映射表，如a的key_map映射为a，而shift_map映射为A
			testb $0x20,mode 											//alt键是否同时按下
			jne 1f																
			lea shift_map,%ebx 										//若按下则映射到shift_map
			testb $0x03,mode 
			jne 1f
			lea key_map,%ebx
		1:																			//从1f开始，ebx放的是map起始地址
			movb (%ebx,%eax),%al 									//扫描码索引(map+scan_code)，ASCII码->al
			orb %al,%al 													//没有对应的ASCII码
			je none 															//没有则跳转 none
			testb $0x4c,mode 											//看caps是否亮
			je 2f 
			cmpb $’a,%al 
			jb 2f
			cmpb $’},%al 
			ja 2f 
			subb $32,%al 													//变大写
		2:
			testb $??,mode												//处理其他模式，如ctrl同时按下
		3:
			andl $0xff,%eax 
			call put_queue												//将ASCII(al)放入读取缓冲区,待CPU读取
		none:
			ret
		
			其中，美式键盘键盘映射表
			#if defined(KBD_US)
				key_map: 
					.byte 0,27
					.ascii “1234567890-=“ 
					...
				shift_map: 
					.byte 0,27
					.ascii “!@#$%^&*()_+” 
					...
					
			#elif defined(KBD_GR) 
				...
		
			put_queue：
				movl _table_list,%edx								//将_table_list地址->edx
				movl head(%edx),%ecx								//偏移head个字节的内容->ecx head=4
			1:
				movb %al,buf(%edx,%ecx)							//al->edx+ecx+buf(16)
	
				其中，kernel/chr_drv/tty_io.c
				struct tty_queue *table_list[]={
					&tty_table[0].read_q,							//读队列
					&tty_table[0].write_q;						//写队列
					...
				};
				
				
完成键盘按键中断放入缓冲队列，待用户read
read -> sys_read
fs/read_write.c
int sys_read(unsigned int fd,char * buf,int count)
{
	struct file * file;
	struct m_inode * inode;
	
	file=current->filp[fd];
	inode = file->f_inode;
	
	if(S_ISCHR(inode->i_mode))
		return rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);
}

fs/char_dev.c
int rw_char(int rw,int dev, char * buf, int count, off_t * pos) 
{
	crw_ptr call_addr;
	
	call_addr=crw_table[MAJOR(dev)];
	return call_addr(rw,MINOR(dev),buf,count,pos);
}

	其中，
	static crw_ptr crw_table[]={
		...
		rw_ttyx,    /* /dev/ttyx */
		...
	};

static int rw_ttyx(int rw,unsigned minor,char * buf,int count,off_t * pos)
{
	return ((rw==READ)?tty_read(minor,buf,count):tty_write(minor,buf,count));
}

kernel/chr_drv/tty_io.c
int tty_read(unsigned channel, char * buf, int nr)
{
	struct tty_struct *tty;
	//b指向user层的buf
	char c, *b=buf;
	
	
	tty = &tty_table[channel];
	
	while (nr>0) {
		if (EMPTY(tty->secondary) || (L_CANON(tty) && !tty->secondary.data && LEFT(tty->secondary)>20)) {
			//缓冲区为空，阻塞等待
			sleep_if_empty(&tty->secondary);
			continue;
		}
		do {
			//采用secondary传给用户 secondary -> c
			GETCH(tty->secondary,c);

			//返回用户空间 c -> *b
			put_fs_byte(c,b++);
			if (!--nr){
				break;
			}
		} while (nr>0 && !EMPTY(tty->secondary));
	}
}


以及控制台的“回显”
回到 kernel/chr_drv/keyboard.S
_keyboard_interrupt：
	pushl $0
	call _do_tty_interrupt				

kernel/chr_drv/tty_io.c
void do_tty_interrupt(int tty)
{ 
	copy_to_cooked(tty_table+tty); 						//上面传来的是0
}

void copy_to_cooked(struct tty_struct *tty)
{ 
	GETCH(tty->read_q,c);											//获取read_q->c
	if(L_ECHO(tty)){ 													//判断是否显示
		PUTCH(c,tty->write_q);									//采用write_q回显屏幕，c->write_q
		tty->write(tty); 												//调用 con_write，立刻显示到屏幕上
	}
	PUTCH(c,tty->secondary); 									//c->secondary
	...
	wake_up(&tty->secondary.proc_list);
}	
	
	
conclude:
	read_q >> secondary(用户read),write_q(回显)
	
	按键->键盘中断处理->put_queue(>>read_q)
		(回显)->do_tty_interrupt->copy_to_cooked(>>secondary,write_q)->con_write(write_q)
		(用户read)->sys_read->rw_char->call_addr->rw_ttyx->tty_read->GETCH(secondary)->put_fs_byte		
		

	
	
											系统调用(write)	read_write.c
															|
															|
									字符设备接口(crw_table[]) char_dev.c
										|										|
										|										|
						tty设备写(tty_write)		tty设备读(tty_read)
										|										|
										|										|
										|								secondary队列
										|										|
										|				 回显				|
								write_q队列	――――――	read_q队列(tty_io.c)
										|										|
										|										|
			console.c 显示器写(con_write)			|(keyboard.S)
										|										|
										|										|
									显示器						主机键盘
									