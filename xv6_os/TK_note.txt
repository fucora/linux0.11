###进程和内存
exec 会替换调用它的进程的内存但是会保留它的文件描述符表。

当exec执行成功后，它并不返回到原来的调用进程，而是从ELF头中声明的入口开始，执行从文件中加载的指令。exec 接受两个参数：可执行文件名和一个字符串参数数组。
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");



I/O 和文件描述符
代表了一个进程可以读写的被内核管理的对象，是该对象在进程表中的索引。
一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符。
fork 一个进程，重新打开指定文件的文件描述符，然后执行新的程序。
char *argv[2];
argv[0] = "cat";
### argv[1] = 0;
if(fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}

cat 的本质实现
char buf[512];
int n;

for(;;){
    n = read(0, buf, sizeof buf);
    if(n == 0)
        break;
    if(n < 0){
        fprintf(2, "read error\n");
        exit();
    }
    if(write(1, buf, n) != n){
        fprintf(2, "write error\n");
        exit();
    }
}



fork 复制了文件描述符，但每一个文件当前的偏移仍然是在父子进程之间共享的
if(fork() == 0) {
    write(1, "hello ", 6);
    exit();
} else {
    wait();
    write(1, "world\n", 6);
}

dup 复制一个已有的文件描述符，返回一个指向同一个输入/输出对象的新描述符。这两个描述符共享一个文件偏移，正如被 fork 复制的文件描述符一样。
fd = dup(1);
write(1, "hello", 6);
write(fd, "world\n", 6);

2>&1 告诉 shell 给这条命令一个复制描述符1的描述符2
close(2);
dup(1);



管道
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    write(p[1], "hello world\n", 12);
    close(p[0]);
    close(p[1]);
}
当 wc 从标准输入读取时，它实际上是从管道读取的。
如果数据没有准备好，那么对管道执行的read会一直等待，直到有数据了或者其他绑定在这个管道写端口的描述符都已经关闭了。



文件系统
open("a", O_CREATE|O_WRONGLY);
link("a", "b");
系统调用 unlink 从文件系统移除一个文件名。一个文件的 inode 和磁盘空间只有当它的链接数变为 0 的时候才会被清空，也就是没有一个文件再指向它。


fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
是创建一个临时 inode 的最佳方式，这个 inode 会在进程关闭 fd 或者退出的时候被清空。


















